; Mine8088 - Minesweeper for I8088 - ziplantil 2026
; Version 2026-01-18
; Compile with NASM
; Tab size: 8

	CPU	8086
	ORG	0100H

[BITS 16]
; MDA=1 FOR MDA, MDA=0 FOR CGA
%IFNDEF MDA
%DEFINE MDA 		0
%ENDIF
; EITHER COLUMNS=40 OR COLUMNS=80
%IFNDEF COLUMNS
%DEFINE COLUMNS 	80
%ENDIF
%DEFINE ROWS 		25

%IF MDA > 0
; MDA
%DEFINE TEXTSEG 	0B000H
%DEFINE TEXTOFF 	0
%IF COLUMNS > 80
%ERROR "COLUMNS MUST NOT EXCEED 80"
%ELSE
; MDA 80 COLUMNS
%DEFINE VMODE 		07H
%ENDIF
%ELSE
; CGA
%DEFINE TEXTSEG 	0B800H
%DEFINE TEXTOFF 	0

%IF COLUMNS > 80
%ERROR "COLUMNS MUST NOT EXCEED 80"
%ELIF COLUMNS > 40
; CGA 80 COLUMNS
%DEFINE VMODE 		03H
%ELSE
; CGA 40 COLUMNS
%DEFINE VMODE 		01H
%ENDIF
%ENDIF

%DEFINE MINWIDE 	3
%DEFINE MINHIGH 	3
%DEFINE MAXWIDE 	(COLUMNS)
%DEFINE MAXHIGH 	(ROWS-1)
%DEFINE FIELDX 		0
%DEFINE FIELDY 		1
%DEFINE STATUSY 	0
%DEFINE STATUSOF 	(STATUSY*COLUMNS*2)
%DEFINE STIMEOFF 	(STATUSOF+6*2)
%DEFINE SMINEOFF 	(STATUSOF+(COLUMNS-3)*2)

%DEFINE FWIDE 		PARAMS
%DEFINE FHIGH 		PARAMS+2
%DEFINE FMINES 		PARAMS+4
%DEFINE BWIDE 		BOUNDS
%DEFINE BHIGH 		BOUNDS+1

%IF COLUMNS > 60
%DEFINE SMSGOFF 	(STATUSOF+(COLUMNS/2-18)*2)
%ELSE
%DEFINE SMSGOFF 	(STATUSOF+(COLUMNS/2-8)*2)
%ENDIF

SECTION .text

MAIN:
	PUSH	CS
	POP	DS
	PUSH	DS
	POP	ES
	CLD

	; READ AND SAVE OLD VIDEO MODE
	MOV	AH, 0FH
	INT	10H
	MOV	[OLDVIDEO], AL

	; PRINT INTRO TEXT
	MOV	AH, 09H
	MOV	DX, INTROTXT
	INT	21H

MODEPRMT:
	; WAIT FOR USER TO PRESS KEY
	XOR	AX, AX
	INT	16H

	CMP	AH, 30H ; B
	JE	SETMODEB
	CMP	AH, 17H ; I
	JE	SETMODEI
	CMP	AH, 12H ; E
	JE	SETMODEE
	CMP	AH, 2EH ; C
	JE	SETMODEC
	CMP	AH, 01H ; ESC
	JNE	MODEPRMT

	MOV	AH, 09H
	MOV	DX, NEWLINE
	INT	21H
THANKS:
	MOV	AH, 09H
	MOV	DX, THANKTXT
	INT	21H

	; EXIT
	XOR	AX, AX
	INT	21H

QUIT:
	; RESTORE OLD VIDEO MODE
	MOV	AH, 00H
	MOV	AL, [OLDVIDEO]
	INT	10H
	JMP	THANKS

SETMODEB:
	MOV	SI, DTAMODEB
	JMP	INITPLAY
SETMODEI:
	MOV	SI, DTAMODEI
	JMP	INITPLAY
SETMODEE:
	MOV	SI, DTAMODEE
	JMP	INITPLAY
SETMODEC:
CWIDEGET:
	; PROMPT USER FOR WIDTH
	MOV	AH, 09H
	MOV	DX, CWIDETXT
	INT	21H
	MOV	SI, 3
	MOV	DI, MAXWIDE
	MOV	CL, 3
	CALL	CREADINT
	JNC	CWIDEOK
	CALL	CPRINTER
	JMP	CWIDEGET
CWIDEOK:
	MOV	[PARAMS], AX

	; PROMPT USER FOR HEIGHT
CHIGHGET:
	MOV	AH, 09H
	MOV	DX, CHIGHTXT
	INT	21H
	MOV	SI, 3
	MOV	DI, MAXHIGH
	MOV	CL, 3
	CALL	CREADINT
	JNC	CHIGHOK
	CALL	CPRINTER
	JMP	CHIGHGET
CHIGHOK:
	MOV	[PARAMS+2], AX

	; CHECK MAXIMUM NUMBER OF MINES ALLOWED FOR GRID
	MOV	AL, [PARAMS]
	DEC	AL
	MOV	DL, [PARAMS+2]
	DEC	DL
	MUL	DL
	MOV	[PARAMS+4], AX

	; PROMPT USER FOR NUMBER OF MINES
CMINEGET:
	MOV	AH, 09H
	MOV	DX, CMINETXT
	INT	21H
	MOV	SI, 1
	MOV	DI, 999
	MOV	CL, 3
	CALL	CREADINT
	JNC	CMINEOK
	CALL	CPRINTER
	JMP	CMINEGET
CMINEOK:

	; APPLY MINES ONLY IF BELOW MAX COUNT DETERMINED EARLIER
	CMP	AX, [PARAMS+4]
	JGE	CMAXMINE
	MOV	[PARAMS+4], AX
CMAXMINE:
	LEA	SI, [PARAMS]
	JMP	INITPLAY

CPRINTER:
	MOV	AH, 09H
	MOV	DX, CIERRTXT
	INT	21H
	RET

CREADINT:
	; READ 16-BIT INTEGER TO AX FROM USER INPUT
	; CL IS NUMBER OF DIGITS ALLOWED
	; SI IS MIN ALLOWED VALUE, DI IS MAX ALLOWED VALUE
	; CLOBBERS BASICALLY EVERYTHING
	; CF SET ON ERROR, CLEAR IF OK
	INC	CL
	MOV	[NBUFFER], CL
	JMP	CREADIN2
CREADIN2:
	MOV	AH, 0AH
	LEA	DX, [NBUFFER]
	INT	21H

	PUSH	SI
	XOR	DX, DX

	; NOW CONVERT BUFFER TEXT TO INT
	MOV	BL, 10
	XOR	CX, CX
	MOV	CL, [NBUFFER+1]
	LEA	SI, [NBUFFER+2]
CRDIGNXT:
	; MUL 10 FOR NEXT DIGIT
	MOV	AX, 10
	MUL	DX
	MOV	DX, AX
	LODSB
	CBW
	CMP	AL, 30H
	JL	CRINTER2
	CMP	AL, 39H
	JG	CRINTER2
	AND	AL, 0FH
	ADD	DX, AX
	LOOP	CRDIGNXT

	POP	SI
	MOV	AX, DX
	; BOUNDS VALIDATION WITH [SI, DI]
	CMP	AX, SI
	JL	CRINTERR
	CMP	AX, DI
	JG	CRINTERR
	CLC
	RET
CRINTER2:
	POP	SI
CRINTERR:
	STC
	RET

CALCSIC:
	; COMPUTE CURSOR OFFSET FOR SI (FIELD)
	; CLOBBERS AX
	MOV	AX, [CURSOR]
CALCSI:
	; COMPUTE OFFSET FOR SI (FIELD)
	; FROM X (AL) AND Y (AH) COORDINATE
	; CLOBBERS AX
	MOV	SI, AX
	AND	SI, 0FFH
	MOV	AL, AH
	MUL	BYTE [FWIDE]
	ADD	SI, AX
	ADD	SI, FIELD
	RET

CALCDIC:
	; COMPUTE CURSOR OFFSET FOR DI (SCREEN)
	; CLOBBERS AX
	MOV	AX, [CURSOR]
CALCDI:
	; COMPUTE OFFSET FOR DI (SCREEN)
	; FROM X (AL) AND Y (AH) COORDINATE
	; CLOBBERS AX
	MOV	DI, AX
	AND	DI, 0FFH
	MOV	AL, AH
	MOV	AH, COLUMNS
	MUL	AH
	ADD	DI, AX
	SHL	DI, 1
	ADD	DI, [SCROFF]
	RET

DRAWCURS:
	; DRAW CELL AT CURSOR POSITION
	; SET CARRY TO BLINK/HIGHLIGHT CELL
	; CLOBBERS AX, BX, ADDS 1 TO SI, 2 TO DI
	; SETS ES TO VIDEO MEMORY
%IF MDA > 0
	SBB	BX, BX
	AND	BX, 7700H
%ELSE
	MOV	BX, 0 ; CANNOT CLOBBER CF
	RCR	BX, 1 ; CF=0 -> A=0000H, CF=1 -> A=8000H
%ENDIF
	CALL	CALCSIC
	CALL	CALCDIC
	MOV	AX, TEXTSEG
	MOV	ES, AX
	MOV	AX, BX
	JMP	DRAWCELI
DRAWCELL:
	; DRAWS MINEFIELD CELL FROM DS:SI TO ES:DI
	; SET CARRY TO BLINK/HIGHLIGHT CELL
	; CLOBBERS AX, BX, ADDS 2 TO DI
	; ASSUMES ES SET TO VIDEO MEMORY
%IF MDA > 0
	SBB	AX, AX
	AND	AX, 7700H
%ELSE
	MOV	AX, 0 ; CANNOT CLOBBER CF
	RCR	AX, 1 ; CF=0 -> A=0000H, CF=1 -> A=8000H
%ENDIF
DRAWCELI:
	XOR	BX, BX
	MOV	BL, [SI]
	TEST	BL, 0C0H
	JNZ	DRAWCLSP
	SHL	BX, 1
%IF MDA > 0
	MOV	AX, [BX+CELLDATA]
%ELSE
	OR	AX, [BX+CELLDATA]
%ENDIF
	STOSW
	RET
DRAWCLSP:
	; DRAW UNREVEALED, FLAG OR MARK
	TEST	BL, 80H
	JNZ	DRAWFLMK
	; DRAW UNREVEALED
%IF MDA > 0
	MOV	AX, [CELLUNRV]
%ELSE
	OR	AX, [CELLUNRV]
%ENDIF
	STOSW
	RET
DRAWFLMK:
	; DRAW FLAG OR MARK
	TEST	BL, 040H
	JNZ	DRAWMARK
	; DRAW FLAG
%IF MDA > 0
	; USE XOR TO DISABLE REVERSE VIDEO
	; NEEDED FOR CURSOR TO WORK OVER FLAGS
	XOR	AX, [CELLFLAG]
%ELSE
	OR	AX, [CELLFLAG]
%ENDIF
	STOSW
	RET
DRAWMARK:
	; DRAW MARK
%IF MDA > 0
	; USE XOR TO DISABLE REVERSE VIDEO
	; NEEDED FOR CURSOR TO WORK OVER FLAGS
	XOR	AX, [CELLMARK]
%ELSE
	OR	AX, [CELLMARK]
%ENDIF
	STOSW
	RET

DRAWFELD:
	; REDRAW FULL PLAYFIELD
	; CLOBBERS BASICALLY EVERYTHING
	; SETS ES TO VIDEO MEMORY
	MOV	AX, TEXTSEG
	MOV	ES, AX
	XOR	AX, AX
	CALL	CALCDI
	LEA	SI, [FIELD]
	MOV	CX, [FHIGH]
INEXTROW:
	PUSH	CX
	PUSH	DI
	MOV	CX, [FWIDE]
INXTCELL:
	CLC
	CALL	DRAWCELL
	INC	SI
	LOOP	INXTCELL
	POP	DI
	ADD	DI, COLUMNS*2
	POP	CX
	LOOP	INEXTROW
	RET

REVEAL:
	; REVEAL TILE UNDER SI (FIELD)
	; IF REVEALED, DECREMENT NUMBER OF REMAINING TILES
	; RETURNS TILE IN AL
	; CLOBBERS AX, DX
	; ASSUMES ES SET TO VIDEO MEMORY

	; CHECK TILE TYPE
	; UNREVEALED: REVEAL
	; MARKED: REVEAL
	; OTHERWISE, NO REVEAL
	MOV	AL, [SI]
	TEST	AL, 40H
	JZ	NREVEAL
	; REVEAL TILE
	AND	AL, 3FH
	; CHECK IF REVEALED MINE
	CMP	AL, 09H
	JE	HITMINE
	; STORE TILE BACK, DECREMENT TILE COUNTER
	MOV	[SI], AL
	DEC	WORD [NUMTILES]
NREVEAL:
	RET

CHKFLOOD:
	; REVEAL TILE AND ADD TO QUEUE AT DI IF SHOULD CONTINUE FLOODING
	; CLOBBERS AX, DX, SI
	MOV	DX, AX
	CALL	CALCSI
	MOV	AL, [SI]
	; GO TO NOFLOOD IF TILE IS REVEALED, FLAGGED OR MARKED
	TEST	AL, 0C0H
	JZ	NOFLOOD
	TEST	AL, 80H
	JNZ	NOFLOOD
	; REVEAL TILE
	CALL	REVEAL
	; REDRAW TILE
	PUSH	BX
	PUSH	DI
	MOV	AX, DX
	CALL	CALCDI
	CLC
	CALL	DRAWCELL
	POP	DI
	POP	BX
	MOV	AL, [SI]
	; NOFLOOD IF TILE IS NOT EMPTY
	OR	AL, AL
	JNZ	NOFLOOD
	; ADD DX TO QUEUE
	MOV	[DI], DX
	INC	DI
	INC	DI
	CMP	DI, QEND
	JGE	FLOODRDI
NOFLOOD:
	RET
FLOODRDI:
	MOV	DI, QUEUE
	RET

INITPLAY:
	; SET UP PARAMS AND BOUNDS
	MOV	DI, PARAMS
	MOV	CX, 6
	REP	MOVSB
	MOV	AL, [FWIDE]
	DEC	AL
	MOV	[BWIDE], AL
	MOV	AL, [FHIGH]
	DEC	AL
	MOV	[BHIGH], AL

	; SET UP VIDEO MODE
	MOV	AX, VMODE
	INT	10H
%IF MDA = 0
	; HIDE CURSOR
	MOV	AH, 01H
	MOV	CX, 2020H
	INT	10H
%ENDIF
	; DISABLE BLINK
	XOR	AX, AX
	MOV	ES, AX
	MOV	DX, [ES:0463H]
	ADD	DX, 4
	MOV	AL, [ES:0465H]
	AND	AL, 0DFH
	OUT	DX, AL
	MOV	[ES:0465H], AL
	MOV	AX, 1003H
	INT	10H
	JMP	START1

HITMINE:
	; USER REVEALED A MINE TILE AT AL (X), AH (Y), SI (FIELD)
	; SET TO HIT MINE
	MOV	BYTE [SI], 0AH

	; REVEAL ALL MINE POSITIONS, AND REPLACE INCORRECT FLAGS WITH CROSS
	MOV	AL, [FWIDE]
	MUL	BYTE [FHIGH]
	MOV	CX, AX
	LEA	SI, [FIELD]
HITMINEC:
	MOV	AL, [SI]
	CMP	AL, 49H ; MINE NOT REVEALED
	JE	HITMINEM
	CMP	AL, 0C9H ; MINE MARKED
	JE	HITMINEM
	CMP	AL, 89H ; MINE FLAGGED
	JE	HITMINEL
	AND	AL, 0C0H
	CMP	AL, 80H
	JNE	HITMINEL
	; TILE WAS FLAGGED, BUT NOT MINE
	MOV	BYTE [SI], 0BH
	JMP	HITMINEL
HITMINEM:
	MOV	BYTE [SI], 09H
HITMINEL:
	INC	SI
	LOOP	HITMINEC
GAMEOVER:
	CALL	DRAWFELD
	LEA	SI, [SMSGLOSE]
	LEA	DI, [SMSGOFF]
	CALL	SPRINT

GAMEEND:
%IF MDA > 0
	; HIDE CURSOR
	MOV	AH, 01H
	MOV	CX, 2020H
	INT	10H
%ENDIF
	XOR	AX, AX
	INT	16H
	CMP	AH, 01H ; ESC
	JE	QUIT
	CMP	AH, 10H ; Q
	JE	QUIT
	CMP	AH, 13H ; R
	JNE	GAMEEND

	; CLEAR MESSAGE
	LEA	DI, [SMSGOFF]
	MOV	CX, 36
	CALL	SCLEAR

START1:
	PUSH	DS
	POP	ES
RESTART:
	; RESTART GAME
	MOV	BYTE [INITFLAG], 1

%IF MDA > 0
	; SET UP CURSOR
	MOV	AH, 01H
	MOV	CX, 001FH
	INT	10H
%ENDIF

	; RESET PLAYFIELD TO UNREVEALED EMPTY (40H)
	MOV	CX, MAXWIDE*MAXHIGH
	MOV	AX, 0040H
	MOV	DI, FIELD
	REP	STOSB

	; INIT SOME VARIABLES, SUCH AS NUMTILES
	XOR	AX, AX
	MOV	[CURSOR], AX
	MOV	[NUMFLAGS], AX
	MOV	[TIMESEC], AX
	MOV	[SCROFF], AX
	MOV	AL, [FWIDE]
	MUL	BYTE [FHIGH]
	MOV	[NUMTILES], AX

	; SET UP SCROFF AND CUROFF
	MOV	DI, TEXTOFF+(COLUMNS*FIELDY+FIELDX)*2
	MOV	[SCROFF], DI
	MOV	AL, COLUMNS
	SUB	AL, [FWIDE]
	SUB	AL, FIELDX
	SHR	AL, 1
	MOV	AH, ROWS
	SUB	AH, [FHIGH]
	SUB	AH, FIELDY
	SHR	AH, 1
	PUSH	AX
	CALL	CALCDI
	MOV	[SCROFF], DI
	POP	AX
	ADD	AL, FIELDX
	ADD	AH, FIELDY
	MOV	[CUROFF], AX

	; DRAW BACKGROUND
	MOV	AX, TEXTSEG
	MOV	ES, AX
	MOV	AX, [BGDATA]
	MOV	CX, ROWS*COLUMNS
	XOR	DI, DI
	REP	STOSW

	; CHECK IF CAN EASILY DRAW SHADOW
	MOV	AL, [CUROFF]
	ADD	AL, [FWIDE]
	CMP	AL, COLUMNS
	JGE	NOSHADOW
	MOV	AH, [CUROFF+1]
	ADD	AH, [FHIGH]
	CMP	AH, ROWS
	JGE	NOSHADOW
	; DRAW SHADOW
	; SHADOW RIGHT SIDE
	MOV	AH, 01H
	MOV	AL, [FWIDE]
	CALL	CALCDI
	XOR	CH, CH
	MOV	CL, [FHIGH]
	XOR	AX, AX
SHADOWY:
	MOV	[ES:DI], AX
	ADD	DI, COLUMNS*2
	LOOP	SHADOWY
	; SHADOW BOTTOM SIDE
	MOV	AH, [FHIGH]
	MOV	AL, 01H
	CALL	CALCDI
	XOR	AX, AX
	XOR	CH, CH
	MOV	CL, [FWIDE]
	REP	STOSW
NOSHADOW:

	; DRAW PLAYFIELD
	CALL	DRAWFELD

	; DRAW MENU BAR
	LEA	DI, [STATUSOF]
	MOV	CX, COLUMNS
	XOR	AL, AL
	MOV	AH, [STATUSC]
	REP	STOSW
	LEA	SI, [STIMETXT]
	LEA	DI, [STATUSOF]
	CALL	SPRINT
	LEA	SI, [SMINETXT]
	LEA	DI, [STATUSOF+(COLUMNS-10)*2]
	CALL	SPRINT
	CALL	SUPDTIME
	CALL	SUPDMINE

	; COMPUTE INITIAL CURSOR POSITION
	MOV	AL, [FWIDE]
	SHR	AL, 1
	MOV	AH, [FHIGH]
	SHR	AH, 1
	MOV	[CURSOR], AX
%IF MDA > 0
	CALL	UPDCUR
%ENDIF
	; ENTER GAME LOOP

GAMELOOP:
	; REDRAW TILE UNDER CURSOR WITH HIGHLIGHT
	STC
	CALL	DRAWCURS

	CMP	BYTE [INITFLAG], 0
	; DO NOT UPDATE TIMER IF PLAYER HAS NOT STARTED GAME
	JNZ	WAITKEY
	; DO NOT UPDATE TIMER IF IT HAS MAXED OUT
	MOV	AX, [TIMESEC]
	CMP	AX, 999
	JGE	WAITKEY
WAITINTR:
	; WAIT FOR TIMER/KEYBOARD, ETC. INTERRUPT
	STI
	HLT
	; GOT INTERRUPT OF SOME KIND
	; CHECK TIMER NOW
	XOR	AX, AX
	INT	1AH
	SUB	DX, [TIMERS]
	SBB	CX, [TIMERS+2]
	JCXZ	NOTMOVF1
	MOV	DX, 0FFFFH
NOTMOVF1:
	; CONVERT DX LOW TICKS TO SECONDS IN HIGH WORD
	; ONE SECOND IS 1640625/90112 TICKS
	; WE WANT TO CONVERT TICKS TO 1/65536 SECONDS
	; THIS GIVES US A MULTIPLIER OF 3600 (~ 65536*90112/1640625)
	MOV	AX, 3600
	MUL	DX
	CMP	DX, [TIMESEC]
	JE	NOSECUPD
	MOV	[TIMESEC], DX
	CALL	SUPDTIME
NOSECUPD:
	CMP	WORD [NUMTILES], 0
	JZ	GAMEWIN
	; CHECK IF WE HAVE A KEY AVAILABLE IN BUFFER
	MOV	AH, 01H
	INT	16H
	; NO KEY, GO WAIT AGAIN
	JZ	WAITINTR
WAITKEY:
	CMP	WORD [NUMTILES], 0
	JZ	GAMEWIN
	; WAIT FOR KEY (OR GET KEY IF ALREADY WAITED)
	XOR	AX, AX
	INT	16H

	CMP	AH, 4BH ; LEFT ARROW
	JE	GOLEFT
	CMP	AH, 4DH ; RIGHT ARROW
	JE	GORIGHT
	CMP	AH, 48H ; UP ARROW
	JE	GOUP
	CMP	AH, 50H ; DOWN ARROW
	JE	GODOWN
	CMP	AH, 39H ; SPACE
	JE	DOREVEAL
	CMP	AH, 21H ; F
	JE	DOFLAG
	CMP	AH, 32H ; M
	JE	DOMARK
	CMP	AH, 01H ; ESC
	JE	QUIT
	CMP	AH, 10H ; Q
	JE	QUIT
	CMP	AH, 13H ; R
	JE	START1
	JMP	GAMELOOP

GAMEWIN:
	; REDRAW TILE UNDER CURSOR *WITHOUT* HIGHLIGHT
	CLC
	CALL	DRAWCURS
	LEA	SI, [SMSGWON]
	LEA	DI, [SMSGOFF]
	CALL	SPRINT
	JMP	GAMEEND

GOLEFT:
	; CHECK IF WE CAN GO LEFT
	CMP	BYTE [CURSOR], 0
	JE	GAMELOOP
	; REMOVE HIGHLIGHT
	CLC
	CALL	DRAWCURS
	; MOVE LEFT
	DEC	BYTE [CURSOR]
%IF MDA > 0
	CALL	UPDCUR
%ENDIF
	JMP	GAMELOOP
GORIGHT:
	; CHECK IF WE CAN GO RIGHT
	MOV	AL, [BWIDE]
	CMP	BYTE [CURSOR], AL
	JGE	GAMELOOP
	; REMOVE HIGHLIGHT
	CLC
	CALL	DRAWCURS
	; MOVE RIGHT
	INC	BYTE [CURSOR]
%IF MDA > 0
	CALL	UPDCUR
%ENDIF
	JMP	GAMELOOP
GOUP:
	; CHECK IF WE CAN GO UP
	CMP	BYTE [CURSOR+1], 0
	JE	GAMELOOP
	; REMOVE HIGHLIGHT
	CLC
	CALL	DRAWCURS
	; MOVE UP
	DEC	BYTE [CURSOR+1]
%IF MDA > 0
	CALL	UPDCUR
%ENDIF
	JMP	GAMELOOP
GODOWN:
	; CHECK IF WE CAN GO DOWN
	MOV	AL, [BHIGH]
	CMP	BYTE [CURSOR+1], AL
	JGE	GAMELOOP
	; REMOVE HIGHLIGHT
	CLC
	CALL	DRAWCURS
	; MOVE DOWN
	INC	BYTE [CURSOR+1]
%IF MDA > 0
	CALL	UPDCUR
%ENDIF
	JMP	GAMELOOP
DOFLAG:
	; CHECK TILE TYPE
	CALL	CALCSIC
	MOV	AL, [SI]
	; DO NOTHING IF TILE IS REVEALED
	TEST	AL, 0C0H
	JZ	GAMELOOP
	; CHECK IF TILE IS FLAGGED
	TEST	AL, 040H
	JNZ	SETFLAG
	; MAKE TILE UNREVEALED (REMOVE FLAG)
	AND	AL, 3FH
	OR	AL, 40H
	MOV	[SI], AL
	DEC	WORD [NUMFLAGS]
	INC	WORD [NUMTILES]
	CALL	SUPDMINE
	JMP	GAMELOOP
SETFLAG:
	; CHECK IF FLAG COUNT IS LIMITED
	MOV	AX, [FMINES]
	CMP	[NUMFLAGS], AX
	JGE	GAMELOOP
	; MAKE TILE FLAGGED
	MOV	AL, [SI]
	AND	AL, 3FH
	OR	AL, 80H
	MOV	[SI], AL
	INC	WORD [NUMFLAGS]
	DEC	WORD [NUMTILES]
	CALL	SUPDMINE
	JMP	GAMELOOP
DOMARK:
	; CHECK TILE TYPE
	CALL	CALCSIC
	MOV	AL, [SI]
	; DO NOTHING IF TILE IS REVEALED
	TEST	AL, 0C0H
	JZ	GAMELOOP
	; CHECK THAT TILE HAS NO MARK OR FLAG
	TEST	AL, 80H
	JZ	SETMARK
	; CHECK IF TILE IS MARKED
	TEST	AL, 040H
	JNZ	CLRMARK
	; REMOVE FLAG
	DEC	BYTE [NUMFLAGS]
	INC	WORD [NUMTILES]
	CALL	SUPDMINE
SETMARK:
	; MAKE TILE MARKED
	MOV	AL, [SI]
	AND	AL, 3FH
	OR	AL, 0C0H
	MOV	[SI], AL
	JMP	GAMELOOP
CLRMARK:
	; MAKE TILE UNREVEALED
	AND	AL, 3FH
	OR	AL, 40H
	MOV	[SI], AL
	JMP	GAMELOOP

%IF MDA > 0
UPDCUR:
	; UPDATE CURSOR POSITION
	; CLOBBERS AX, BX, DX
	MOV	AH, 02H
	XOR	BH, BH
	MOV	DX, [CURSOR]
	ADD	DL, [CUROFF]
	ADD	DH, [CUROFF+1]
	INT	10H
	RET
%ENDIF

INITFELD:
	; PREPARE MINEFIELD
	MOV	BYTE [INITFLAG], 0

	; INIT RANDOM NUMBER GENERATOR
	XOR	AX, AX
	MOV	ES, AX
	INT	1AH
	MOV	[RNGSEED], DX
	MOV	AX, [ES:041EH]
	OR	AL, 80H
	MOV	[RNGSEED+2], AX
	PUSH	DS
	POP	ES

	; PLACE MINES INITIALLY
	MOV	DI, FIELD
	XOR	DX, DX
	MOV	CX, [FMINES]
PMINENXT:
	; KEEP TWO HI BITS UNCHANGED
	MOV	AL, [DI]
	AND	AL, 0C0H
	OR	AL, 09H
	STOSB
	LOOP	PMINENXT

	; GET EVACUATION TILES
	MOV	DX, [CURSOR]
	MOV	AX, DX
	CALL	CALCSI
	CALL	CHKNGHBR

	MOV	BX, [NCOUNT]
	INC	BL
	MOV	AL, [FWIDE]
	MUL	BYTE [FHIGH]
	; AX = TOTAL NUMBER OF TILES
	SUB	AX, BX
	; NOW AX = TOTAL NUMBER OF TILES - EVACUATED TILES
	; ENSURE IT IS NOT UNDER THE TOTAL NUMBER OF MINES
	MOV	BX, [FMINES]
	CMP	AX, BX
	JGE	NOSETM
	MOV	AX, [FMINES]
NOSETM:
	; NOW SHUFFLE THE FIELD TO RANDOMLY PLACE MINES
	MOV	DX, AX
	MOV	SI, FIELD-1
	ADD	SI, DX
NSHUFFLE:
	PUSH	DX
RANDOM:
	; GENERATE RANDOM NUMBER IN AX [0, DX)
	; CLOBBERS AX, CX, DX
	PUSH	DX
	; GENERATE RANDOM 16-BIT NUMBER IN AX
	; XORSHIFT
	MOV	AX, [RNGSEED+2]
	MOV	DX, AX
	MOV	CL, 7
	SHL	DX, CL
	XOR	AX, DX
	MOV	DX, AX
	MOV	CL, 9
	SHR	DX, CL
	XOR	AX, DX
	MOV	DX, AX
	MOV	CL, 8
	SHL	DX, CL
	XOR	AX, DX
	MOV	[RNGSEED+2], AX
	; LCG
	MOV	AX, [RNGSEED]
	MOV	DX, 39917
	MUL	DX
	ADD	AX, 31071
	MOV	[RNGSEED], AX
	; XOR LCG AND XORSHIFT
	XOR	AX, [RNGSEED+2]
	; NOW AX IS 16-BIT RANDOM
	POP	DX
	MUL	DX
	; NOW DX IS [0, ORIGINAL DX)
	MOV	BX, DX
	; INLINED RET
	LEA	DI, [BX+FIELD]
	CALL	SWAPLO6
	DEC	SI
	POP	DX
	DEC	DX
	CMP	DX, 1
	JG	NSHUFFLE

	; NOW EVACUATE TILES AROUND CURSOR
	MOV	AL, [FWIDE]
	MUL	BYTE [FHIGH]
	MOV	DI, AX
	ADD	DI, FIELD

	CALL	CALCSIC
	CALL	EVACMINE

	MOV	CX, [NCOUNT]
	LEA	SI, [NBUFFER]
EVACNEXT:
	LODSW
	PUSH	SI
	MOV	SI, AX
	CALL	EVACMINE
	POP	SI
	LOOP	EVACNEXT

	; NEXT, SCAN MINES TO SET UP TILE NUMBERS
	XOR	DX, DX
	MOV	SI, FIELD
CONTSCAN:
	MOV	AL, [SI]
	CMP	AL, 49H
	JNE	NEXTSCAN
	; FOUND MINE, DO NEIGHBOR CHECK
	PUSH	DX
	CALL	CHKNGHBR
	POP	DX

	MOV	CX, [NCOUNT]
	PUSH	SI
	LEA	SI, [NBUFFER]
NEXTINCR:
	LODSW
	MOV	DI, AX
	; INCREMENT NUMBER AT TILE DI
	MOV	AL, [DI]
	AND	AL, 3FH
	CMP	AL, 8
	JGE	NOINCRDI
	INC	BYTE [DI]
NOINCRDI:
	LOOP	NEXTINCR
	POP	SI
NEXTSCAN:
	INC	SI
	INC	DL
	CMP	DL, [FWIDE]
	JL	CONTSCAN
	XOR	DL, DL
	INC	DH
	CMP	DH, [FHIGH]
	JL	CONTSCAN

	; RESET TIMER
	XOR	AX, AX
	INT	1AH
	MOV	[TIMERS], DX
	MOV	[TIMERS+2], cX

	; FIELD IS NOW SET UP
DOREVEAL:
	CMP	BYTE [INITFLAG], 0
	JNZ	INITFELD
	MOV	AX, [CURSOR]
	CALL	CALCSI
	MOV	AL, [SI]
	; IF TILE IS ALREADY REVEALED, CHORD
	TEST	AL, 0C0H
	JZ	CHORD
	MOV	AX, TEXTSEG
	MOV	ES, AX
	CALL	REVEAL
	; CHECK IF SHOULD REVEAL MORE (FLOOD)
	OR	AL, AL
	JNZ	GAMELOOP
DOFLOOD:
	MOV	AX, [CURSOR]
FLOOD:
	; 'FLOOD' FILL TILE REVEALS FROM TILE AL (X), AH (Y)
	; CLOBBERS BASICALLY EVERYTHING
	LEA	BX, [QUEUE]
	MOV	[QTAIL], BX
	MOV	[BX], AX
	INC	BX
	INC	BX
	MOV	[QHEAD], BX
	JMP	RUNQ
QRESETSI:
	MOV	SI, QUEUE
	JMP	QSITAIL
NEXTQ:
	; RUN QUEUE
	LODSW
	CMP	SI, QEND
	JGE	QRESETSI
QSITAIL:
	MOV	[QTAIL], SI
SUBFLOOD:
	; REVEAL NEIGHBORS OF TILE AL (X), AH (Y)
	; CHECK NEIGHBORS AND ADD THEM TO THE QUEUE
	; CLOBBERS AX, BX, SI, DI
	; SETS ES=DS
	MOV	DI, TEXTSEG
	MOV	ES, DI
	MOV	DI, [QHEAD]
	MOV	BX, AX
	OR	BH, BH
	JE	NENQU
	LEA	AX, [BX-0100H]
	CALL	CHKFLOOD
	OR	BL, BL
	JE	NENQUL
	LEA	AX, [BX-0100H-01H]
	CALL	CHKFLOOD
NENQUL:
	CMP	BL, [BWIDE]
	JE	NENQUR
	LEA	AX, [BX-0100H+01H]
	CALL	CHKFLOOD
NENQUR:
NENQU:
	CMP	BH, [BHIGH]
	JE	NENQD
	LEA	AX, [BX+0100H]
	CALL	CHKFLOOD
	OR	BL, BL
	JE	NENQDL
	LEA	AX, [BX+0100H-01H]
	CALL	CHKFLOOD
NENQDL:
	CMP	BL, [BWIDE]
	JE	NENQDR
	LEA	AX, [BX+0100H+01H]
	CALL	CHKFLOOD
NENQDR:
NENQD:
	OR	BL, BL
	JE	NENQL
	LEA	AX, [BX-01H]
	CALL	CHKFLOOD
NENQL:
	CMP	BL, [BWIDE]
	JE	NENQR
	LEA	AX, [BX+01H]
	CALL	CHKFLOOD
NENQR:
	MOV	[QHEAD], DI
	; INLINED RET
RUNQ:
	MOV	SI, [QTAIL]
	CMP	SI, [QHEAD]
	JNE	NEXTQ
DONEQ:
	; INLINED RET
	JMP	GAMELOOP
CHORD:
	PUSH	DS
	POP	ES
	MOV	DX, [CURSOR]
	; SI IS SET UP CORRECTLY ALREADY
	; CHECK NEIGHBORS FOR TILE
	CALL	CHKNGHBR

	; COUNT NUMBER OF FLAGS SURROUNDING SELECTED TILE (IN DL)
	XOR	DL, DL
	PUSH	SI
	MOV	CX, [NCOUNT]
	LEA	SI, [NBUFFER]
CHORDNXF:
	LODSW
	MOV	BX, AX
	MOV	AL, [BX]
	AND	AL, 0C0H
	CMP	AL, 80H
	JNE	CHORDNOF
	INC	DL
CHORDNOF:
	LOOP	CHORDNXF
	POP	SI
	; IF NUMBER OF FLAGS EQUALS TILE INDEX, START FLOOD
	MOV	AL, [SI]
	CMP	AL, DL
	JE	DOFLOOD
	JMP	GAMELOOP

EVACMINE:
	; EVACUATE MINE FROM SI TO DI-1, DECREMENT DI
	; CLOBBERS AX, DX
	DEC	DI
	MOV	AL, [SI]
	TEST	AL, 03FH
	JZ	NOEVAC
SWAPLO6:
	; SWAP THE LOW 6 BITS OF [DS:SI] AND [DS:DI]
	; CLOBBERS AX, DX
	MOV	AL, [SI]
	MOV	AH, [DI]
	MOV	DL, AL
	AND	AL, 03FH
	AND	DL, 0C0H
	MOV	DH, AH
	AND	AH, 03FH
	AND	DH, 0C0H
	OR	AH, DL
	OR	AL, DH
	MOV	[SI], AH
	MOV	[DI], AL
NOEVAC:
	RET

CHKNGHBR:
	; GET NEIGHBORS FOR DL (X), DH (Y), SI (OFFSET)
	; RETURN OFFSETS IN NBUFFER, COUNT IN NCOUNT
	; CLOBBERS AX, BX, DI
	; NOTE: REQUIRES DS=ES
	LEA	DI, [NBUFFER]
	OR	DH, DH
	JE	NNGBHRU
	MOV	AX, SI
	SUB	AX, [FWIDE]
	STOSW
	MOV	BX, AX
	OR	DL, DL
	JE	NNGBHRUL
	LEA	AX, [BX-1]
	STOSW
NNGBHRUL:
	CMP	DL, [BWIDE]
	JE	NNGBHRUR
	LEA	AX, [BX+1]
	STOSW
NNGBHRUR:
NNGBHRU:
	CMP	DH, [BHIGH]
	JE	NNGBHRD
	MOV	AX, SI
	ADD	AX, [FWIDE]
	STOSW
	MOV	BX, AX
	OR	DL, DL
	JE	NNGBHRDL
	LEA	AX, [BX-1]
	STOSW
NNGBHRDL:
	CMP	DL, [BWIDE]
	JE	NNGBHRDR
	LEA	AX, [BX+1]
	STOSW
NNGBHRDR:
NNGBHRD:
	OR	DL, DL
	JE	NNGBHRL
	LEA	AX, [SI-1]
	STOSW
NNGBHRL:
	CMP	DL, [BWIDE]
	JE	NNGBHRR
	LEA	AX, [SI+1]
	STOSW
NNGBHRR:
	MOV	DX, DI
	SUB	DX, NBUFFER
	SHR	DX, 1
	MOV	[NCOUNT], DX
	RET

SUPDTIME:
	; UPDATE MINE COUNTER IN STATUS BAR
	; CLOBBERS AX, BX
	; SETS ES TO VIDEO MEMORY
	MOV	AX, TEXTSEG
	MOV	ES, AX
	MOV	AX, [TIMESEC]
	LEA	DI, [STIMEOFF]
	CALL	SDISPNUM
	RET

SUPDMINE:
	; UPDATE MINE COUNTER IN STATUS BAR
	; CLOBBERS AX, BX
	; SETS ES TO VIDEO MEMORY
	MOV	AX, TEXTSEG
	MOV	ES, AX
	MOV	AX, [FMINES]
	MOV	BX, [NUMFLAGS]
	SUB	AX, BX
	LEA	DI, [SMINEOFF]
	CALL	SDISPNUM
	RET

SPRINTNX:
	STOSB
	INC	DI
SPRINT:
	; PRINT NULL-TERMINATED STATUS BAR TEXT FROM DS:SI TO ES:DI
	; CLOBBERS AX, SI, DI
	LODSB
	OR	AL, AL
	JNZ	SPRINTNX
	RET

SDISPNUM:
	; DISPLAY THREE-DIGIT NUMBER FROM AX TO ES:DI
	; CLOBBERS AX, BX
	MOV	BL, 10
	DIV	BL
	OR	AH, 30H
	MOV	[ES:DI+4], AH
	XOR	AH, AH
	DIV	BL
	OR	AX, 3030H
	MOV	[ES:DI+2], AH
	MOV	[ES:DI], AL
	RET

SCLEAR:
	; CLEAR CX CHARACTERS FROM STATUS BAR AT ES:DI
	; CLOBBERS AX, DI
	XOR	AL, AL
SCLEARNX:
	STOSB
	INC	DI
	LOOP	SCLEARNX
	RET

SECTION .data

; CONVERT (MIN/MAX)(WIDE/HIGH) TO STRINGS IN PREPROCESSOR
%ASSIGN NMINWIDE MINWIDE
%DEFSTR SMINWIDE NMINWIDE
%ASSIGN NMAXWIDE MAXWIDE
%DEFSTR SMAXWIDE NMAXWIDE
%ASSIGN NMINHIGH MINHIGH
%DEFSTR SMINHIGH NMINHIGH
%ASSIGN NMAXHIGH MAXHIGH
%DEFSTR SMAXHIGH NMAXHIGH

INTROTXT:
	DB	"Mine8088 - Minesweeper for I8088",0DH,0AH
%IF MDA > 0
	DB	"For 80-column MDA",0DH,0AH
%ELSE
%IF COLUMNS > 40
	DB	"For 80-column CGA",0DH,0AH
%ELSE
	DB	"For 40-column CGA",0DH,0AH
%ENDIF
%ENDIF
	DB	0F7H," ziplantil 2026-01-18",0DH,0AH
	DB	09H,"Arrow keys move",0DH,0AH
	DB	09H,"[Space] Reveal/Chord",0DH,0AH
	DB	09H,"[F]lag [M]ark [R]estart",0DH,0AH
	DB	09H,"[Q]uit (or [ESC])",0DH,0AH,0DH,0AH
	DB	"Enter mode",0DH,0AH
	DB	"[B]eginner",0DH,0AH
	DB	"[I]ntermediate",0DH,0AH
	DB	"[E]xpert",0DH,0AH
	DB	"[C]ustom",0DH,0AH,"? $"
NEWLINE:
THANKTXT:
	DB	0DH,0AH,"$"
CWIDETXT:
	DB	0DH,0AH,"Width ("
	DB	SMINWIDE
	DB	"-"
	DB	SMAXWIDE
	DB	")? $"
CHIGHTXT:
	DB	0DH,0AH,"Height ("
	DB	SMINHIGH
	DB	"-"
	DB	SMAXHIGH
	DB	")? $"
CMINETXT:
	DB	0DH,0AH,"Mines (1-999)? $"
CIERRTXT:
	DB	0DH,0AH,"Not valid!$"
STIMETXT:
	DB	"Time:", 0
SMINETXT:
	DB	"Mines:", 0
%IF COLUMNS > 60
SMSGWON:
	; WIN MESSAGE
	DB	01H," YOU WIN! R to replay, ESC to quit",00H
SMSGLOSE:
	; GAME OVER MESSAGE
	DB	" ",0FH," BOOM! R to replay, ESC to quit",00H
%ELSE
SMSGWON:
	; WIN MESSAGE
	DB	01H," [R]etry [Q]uit",00H
SMSGLOSE:
	; GAME OVER MESSAGE
	DB	0FH," [R]etry [Q]uit",00H
%ENDIF

DTAMODEB:
	DW	9, 9, 10
DTAMODEI:
	DW	16, 16, 40
DTAMODEE:
	DW	30, 16, 99

; FIELD FORMAT
; 00 = EMPTY CELL (0 MINES NEARBY)
; 01 = 1 MINE NEARBY
; ...
; 08 = 8 MINES NEARBY
; 09 = MINE
; 0A = HIT MINE (ONLY ON GAME OVER)
; 0B = INCORRECT FLAG (ONLY ON GAME OVER)
; HIGH 2 BITS:
;		 00H	REVEALED
;		 40H	UNREVEALED
;		 80H	FLAGGED
;		0C0H	MARKED

%IF MDA > 0
; TILE DATA FOR MDA
CELLDATA:
	DB	0F0H,07H	; LOW INTENSITY
	DB	"1",0FH 	; HIGH INTENSITY
	DB	"2",0FH 	; HIGH INTENSITY
	DB	"3",0FH 	; HIGH INTENSITY
	DB	"4",0FH 	; HIGH INTENSITY
	DB	"5",0FH 	; HIGH INTENSITY
	DB	"6",0FH 	; HIGH INTENSITY
	DB	"7",0FH 	; HIGH INTENSITY
	DB	"8",0FH 	; HIGH INTENSITY
	DB	0FH,0FH 	; HIGH INTENSITY
	DB	0FH,0F0H	; INVERTED HIGH INTENSITY
	DB	"X",0FH 	; HIGH INTENSITY
CELLUNRV:
	DB	0B2H,07H	; UNREVEALED LOW INTENSITY
CELLFLAG:
	DB	0D5H,70H	; FLAG INVERTED INTENSITY
CELLMARK:
	DB	"?",70H 	; MARK INVERTED INTENSITY
BGDATA:
	DB	0F9H,07H
STATUSC:
	DB	01H		; STATUS BAR UNDERLINE
%ELSE
; TILE DATA FOR CGA
CELLDATA:
	DB	0F9H,78H	; LIGHT GREY BG, DARK GREY FG
	DB	"1",79H 	; LIGHT GREY BG, LIGHT BLUE FG
	DB	"2",7AH 	; LIGHT GREY BG, LIGHT GREEN FG
	DB	"3",7CH 	; LIGHT GREY BG, LIGHT RED FG
	DB	"4",71H 	; LIGHT GREY BG, DARK BLUE FG
	DB	"5",74H 	; LIGHT GREY BG, DARK RED FG
	DB	"6",73H 	; LIGHT GREY BG, DARK CYAN FG
	DB	"7",70H 	; LIGHT GREY BG, BLACK FG
	DB	"8",78H 	; LIGHT GREY BG, DARK GREY FG
	DB	0FH,70H 	; REVEALED MINE LIGHT GREY BG, BLACK FG
	DB	0FH,0CEH	; HIT MINE LIGHT RED BG, YELLOW FG
	DB	"X",7CH 	; BAD FLAG LIGHT GREY BG, LIGHT RED FG
CELLUNRV:
	DB	0B0H,7FH	; UNREVEALED LIGHT GREY BG, WHITE FG
CELLFLAG:
	DB	0D5H,4FH	; FLAG DARK RED BG, WHITE FG
CELLMARK:
	DB	"?",1FH 	; MARK DARK BLUE BG, WHITE FG
BGDATA:
	DB	0B0H,01H
STATUSC:
	DB	1FH		; STATUS BAR COLORS
%ENDIF

SECTION .bss

OLDVIDEO:
	; OLD VIDEO MODE
	RESB	1
RNGSEED:
	; RANDOM NUMBER GENERATION SEEDS
	RESW	2
PARAMS:
	; WIDTH, HEIGHT, NUMBER OF MINES
	RESW	3
CURSOR:
	; CURSOR POSITION: LOBYTE IS X, HIBYTE IS Y
	RESW	1
CUROFF:
	; CURSOR OFFSET ON SCREEN
	RESW	1
BOUNDS:
	; BOUNDS (WIDTH-1, HEIGHT-1)
	RESB	2
SCROFF:
	; SCREEN OFFSET
	RESW	1
NUMTILES:
	; NUMBER OF TILES LEFT TO REVEAL OR FLAG
	RESW	1
NUMFLAGS:
	; NUMBER OF FLAGS SET
	RESW	1
TIMESEC:
	; NUMBER OF SECONDS IN TIMER
	RESW	1
TIMERS:
	; TIMER COUNTS WHEN GAME STARTED
	RESW	2
INITFLAG:
	; WHETHER TO INIT FIELD
	RESB	1
QHEAD:
	; FLOOD CIRCULAR QUEUE HEAD
	RESW	1
QTAIL:
	; FLOOD CIRCULAR QUEUE TAIL
	RESW	1
NCOUNT:
	; NUMBER OF NEIGHBORS IN BUFFER
	RESW	1
NBUFFER:
	; NEIGHBOR BUFFER (MEMORY ADDRESSES INTO FIELD)
	RESW	8
QUEUE:
	; CIRCULAR QUEUE FOR FLOOD OPERATIONS
%IF MAXWIDE > MAXHIGH
	RESW	MAXHIGH*4
%ELSE
	RESW	MAXWIDE*4
%ENDIF
QEND:
FIELD:
	; PLAYFIELD, SEE ABOVE FOR FORMAT
	RESB	MAXWIDE*MAXHIGH

